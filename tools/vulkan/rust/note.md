# Rust note

[rust course](https://course.rs/basic/ownership/ownership.html)

## 通过所有权机制管理内存

1. Rust 中每一个值都被一个变量所拥有，该变量被称之为值的所有者
2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

## 字符串

- " " 字符串字面值，硬编码进可执行文件里的不可变数据，只能通过不可变切片访问
- &str ：不可变切片，引用只读集合内的一段连续数据
- String 存储在堆上的可变大小字符集合，复合类型
- String 变量取引用会隐式转换为切片返回字符串切片
- String 变量执行 String 方法改变 String 后，变量将会指向一个全新的地址
  - 所以 String 变量需要操作的话必须是可变的
  - String 看起来能具备的各种改变内容的操作，但实际上他是不可变的，他实例化了一个新的对象

## 所有权

- 复合变量赋值是进行移动，而不是浅拷贝，移动会销毁旧变量。
  - 一般情况不会直接复合变量赋值，没有意义，这个情况通常是出现在方法形参传递时，进入方法形参的变量将会移交所有权后失效，所有权为方法内部参数持有。
- 值变量赋值是拷贝操作，即浅拷贝操作
- rust 没有深拷贝操作
- 值类型在 Rust 中称为 Copy 类型

## 引用

- Rust 通过借用(Borrowing) 使另外一个变量不通过改变所有权的方式来访问这个变量的值
- 这个操作也称为获取变量的引用

`let y = &x;`

y 是 x 的引用，

`assert_eq!(5, *y)`

*y 来解出引用所指向的值（也就是解引用）

### 方法形参

let s = String::from("hello");
change(&s);
change(s: &String){}

方法形参可以自动解引用,方法作用域过去后，引用变量被释放，但是他不具有所有权，所以对应的值不会被释放。

引用的实质就是栈内数据指针

![&String s pointing at String s1](../../../.gitbook/assets/v2-fc68ea4a1fe2e3fe4c5bb523a0a8247c_1440w.jpg)

### 可变引用

let mut s = String::from("hello");
change(&mut s);
change(s: &mut String){}

### 防止数据竞争
```
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;

println!("{}, {}", r1, r2);
```

- 上面代码存在两个可变引用同一块栈空间
- 就是两个读写指针同时指向了同一块内存
- 在 r2 的作用域区间还访问了 r1
- 为了防止数据竞争，这个代码将不会被编译通过

#### 引用的作用域

从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号 }

#### 高优先级的不可变借用

```
let r1 = &s; // 没问题
let r3 = &mut s; // 大问题
```

同时出现可用和不可变借用时将会报错，不可变借用不希望数据被其他位置修改

### 数据竞争出现的原因

- 两个或更多的指针同时访问同一数据
- 至少有一个指针被用来写入数据
- 没有同步数据访问的机制

### 悬垂引用

- 当变量引用了一个因为超出其作用域而被释放掉的变量时，编译将不会通过

## 复合类型

- #![allow(unused_variables)] 编译器忽略未使用的变量
- 返回一个 ! 类型，这个表明该函数是一个发散函数，不会返回任何值
- unimplemented!() todo!() 告诉编译器该函数尚未实现

### 切片

#### 切片也是引用

- 创建字符串字面量的时候是创建这个字符串的完整切片引用
`let s : &str = "12313" `

#### 切片可以引用堆内存数据

```
let mut s = String::from("hello world");
fn first_word(s: &String) -> &str {
    &s[..1]
}
```
![img](../../../.gitbook/assets/v2-69da917741b2c610732d8526a9cc86f5_1440w.jpg)

#### 切片可以切任意集合类型

```
let a = [1, 2, 3, 4, 5];
let slice = &a[1..3];
```

1. 字符串切片的类型是&str,数组的切片类型是&[T].
2. 字符串切片是按照字节进行索引的,数组切片是按照元素大小进行索引的.

